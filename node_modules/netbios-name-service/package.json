{
  "name": "netbios-name-service",
  "description": "NetBIOS name service implementation written in Javascript.",
  "keywords": [
    "netbios",
    "name",
    "service"
  ],
  "version": "0.3.2",
  "author": {
    "name": "Ben Kelly",
    "email": "ben@wanderview.com"
  },
  "license": "BSD",
  "dependencies": {
    "ip": "~0.0.3",
    "netbios-name": "~0.2.0",
    "readable-stream": "~1.0.0",
    "mac-address": "~0.2.0"
  },
  "devDependencies": {
    "nodeunit": "~0.7.4",
    "pcap-parser": "~0.2.1"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:wanderview/node-netbios-name-service.git"
  },
  "scripts": {
    "test": "nodeunit test"
  },
  "main": "service.js",
  "readme": "# netbios-name-service\n\nA 100% javascript implemention of the NetBIOS name service defined in\n[RFC1001][] and [RFC1002][].\n\n[![Build Status](https://travis-ci.org/wanderview/node-netbios-name-service.png)](https://travis-ci.org/wanderview/node-netbios-name-service)\n\n## Example\n\n``` javascript\nvar Service = require('netbios-name-service');\nvar NBName = require('netbios-name');\n\nvar serv = new Service();\n\nserv.start(function() {\n  serv.on('added', function(opts) {\n    console.log('ADDED: [' + opts.nbname + '] [' +\n                opts.address + ']');\n  });\n\n  serv.on('removed', function(opts) {\n    console.log('REMOVED: [' + opts.nbname + ']');\n  });\n\n  serv.on('error', function(error) {\n    console.log('ERROR: [' + error + ']');\n  });\n\n  var nbname = new NBName({fqdn: 'VMWINXP.example.com'});\n  serv.find(nbname, function(error, address) {\n    console.log('FIND: [' + nbname + '] resulted in [' + address + ']');\n  });\n\n  var nbname2 = new NBName({fqdn: 'FOOBAR.example.com'});\n  serv.add({\n    nbname: nbname2,\n    ttl: 3600,\n  }, function(error, success) {\n    console.log('ADD: [' + nbname2 + '] resulted in [' + success + ']');\n  });\n\n  var badNBName = new NBName({fqdn: 'THISISTOOLONGFORNETBIOS.example.com'});\n  serv.find(badNBName, function(error, address) {\n    console.log('FIND: returned error [' + error + ']');\n    address === null;   // true\n  });\n});\n```\n\n## Common Issues\n\nBy default the name service will attempt to by to port 137.  If you do not\nrun as root or with sudo you will get an error like the following:\n\n```\nError: listen EACCES\n    at errnoException (net.js:847:11)\n    at Server._listen2 (net.js:972:19)\n    at listen (net.js:1018:10)\n    at Server.listen (net.js:1067:5)\n    at NetbiosNameService._startTcp (/Users/bkelly/Dropbox/devel/node-netbios-name-service/service.js:171:23)\n    at NetbiosNameService.start (/Users/bkelly/Dropbox/devel/node-netbios-name-service/service.js:116:8)\n    at Object.<anonymous> (/Users/bkelly/Dropbox/devel/node-netbios-name-service/example/server.js:32:6)\n    at Module._compile (module.js:454:26)\n    at Object.Module._extensions..js (module.js:472:10)\n    at Module.load (module.js:356:32)\n```\n\n\nIn addition, most desktop operating systems run passive NetBIOS name service\ndaemons in order to provide network browsing features.  If this is the case\nyou will receive an error like this:\n\n```\nError: bind EADDRINUSE\n    at errnoException (dgram.js:359:11)\n    at dgram.js:134:26\n    at dns.js:71:18\n    at process._tickCallback (node.js:386:13)\n```\n\nYou will need to disable the default operating system NetBIOS support to avoid\nthis problem.  On Mac OS X this can be done by running the following command:\n\n``` bash\nsudo launchctl unload /System/Library/LaunchDaemons/com.apple.netbiosd.plist\n```\n\nOn Linux it will vary by distribution, but its probably something along the\nlines of:\n\n``` bash\nsudo /etc/init.d/samba stop\n```\n\n## Limitations\n\nThis module provides a useful set of functionality from the RFCs, but it is\nstill a work in progress.\n\nPlease be aware of the following limitations:\n\n* The name service currently only operates in broadcast mode allowing you\n  to interact with peer nodes on the local network.  The point-to-point,\n  mixed, and hybrid modes are not yet implemented.  These would allow the\n  service to interact with a name server such as WINS.\n* Group names are supported, but not tested yet.  In particular, it is\n  likely that you will only be notified of the first IP found and have no\n  way of finding the full list of addresses for nodes.\n* Requesting status from a node with a large number of names will currently\n  result in an error.  In these cases the message may not fit within a UDP\n  packet.  According to the RFC the packet should be marked as truncated and\n re-requested over TCP.  Neither of these actions are currently implemented.\n* The service has only been lightly tested on networks with a few nodes.  In\n  particular, many of the name conflict corner cases have not been tested in a\n  live environment and may contain hidden issues.\n* The API should be considered unstable as it may change in future versions.\n\nFeedback, testing help, and pull requests welcome.\n\n## Class: NetbiosNameService\n\n### new NetbiosNameService(options)\n\nConstruct a new NetbiosNameService object.  The service will not be able to\nsend or receive messages until the `start()` method is called.\n\n* `options` {Object}\n  * `bindAddress` {String | null} The local IPv4 address to use when creating\n    the UDP socket and TCP server.  Defaults to binding to `'0.0.0.0'`.\n  * `broadcastAddress` {String | null} The IPv4 address to use when\n    broadcasting UDP packets.  Defaults to `'255.255.255.255'`.\n  * `defaultTtl` {Number | null} The default time-to-live value to use for\n    names registered with the `add()` method.  Defaults to 3600.\n  * `tcpDisable` {Boolean | null} Disable TCP operations.  This mainly\n    prevents other nodes from contacting the service on TCP.  Defaults to\n    false.\n  * `tcpPort` {Number | null} Specify the port to use when binding the TCP\n    server.  Defaults to 137.\n  * `tcpServer` {Object | null} Provide an existing TCP server that has\n    already been bound.  The service will not open a new server and therefore\n    will ignore the `tcpPort` setting.  Note, the `tcpDisable` option takes\n    precendence and will cause this server object to be ignored.  Also,\n    when the service `stop()` method is called the server will be closed.\n  * `udpPort` {Number | null} Specify the port to use when opening the UDP\n    socket.  Defaults to 137.\n  * `udpSocket` {Object | null} Provide an existing UDP socket instead of\n    creating a new one on `start()`.  If this is provided the `udpPort`\n    option will be ignored.  This socket will be closed when the `stop()`\n    method is called.\n\n### service.start(callback)\n\nStart the NetbiosNameService by opening the UDP socket and creating the\nTCP server.\n\n* `callback` {Function | null} Callback issued when the service has fully\n  started.\n\n### service.stop(callback)\n\nStop the NetbiosNameService by clearing the local name map, the remote\nname cache, and stopping the network services.  This will cause `removed`\nevents to be fired for existing names.\n\n* `callback` {Function | null} Callback issued when the service has fully\n  stopped.\n\n### service.add(options, callback)\n\nRegister the given name for the local NetBIOS node.\n\n* `options` {Object}\n  * `nbname` {Object} The NetBIOS name to register for the local node.  This\n    must be an instance of the NetbiosName class defined in the [netbios-name][]\n    module.\n  * `address` {String | null} The address to use for the local node.  Defaults\n    to the `bindAddress` passed in the `new NetbiosNameService()` options or\n    the first non-internal, IPv4 address returned by `os.networkInterfaces()`.\n  * `group` {Boolean | null} Indicate if the name should registered as part\n    of a group.  Defaults to false.\n  * `ttl` {Number | null} Specify the time-to-live for this name.  Defaults\n    to the `defaultTtl` value passed in the `new NetbiosNameService()` options.\n* `callback` {Function | null} Callback issued when the requested name has\n  been successfully added as a local node or definitively failed.\n  * `error` {Object} The `Error` object associated with any exception\n    conditions and `null` if none occurred.  Note, the `add()` call can still\n    fail due to a name conflict and set the `success` argument `false` without\n    passing an `error`.  The `error` is more for things like malformed packets\n    and network errors.\n  * `success` {Boolean} True if the name was successfuly registered for the\n    local node.  False if the name is already in use on the network by a\n    conflicting node.\n  * `conflictAddress` {String} The IP address of the NetBIOS node that\n    currently owns the specified name. `null` if no conflict is detected.\n\n### service.remove(nbname, callback)\n\nDeregister the given name from the local NetBIOS node.\n\n* `nbname` {Object} The NetBIOS name object to remove that has been registered\n  for the local node with a previous call to `add()`.\n* `callback` {Function | null} Callback issued when the requested name has\n  been successfully deregistered for the local node.\n  * `error` {Object} The `Error` object associated with any exceptional\n    conditions.\n\n### service.find(nbname, callback)\n\nSearch for a NetBIOS name with the given name.\n\n* `nbname` {Object} The NetBIOS name to find.\n* `callback` {Function} Callback issued when the specified name has been\n  found or the service has failed the request.\n  * `error` {Object} The `Error` object associated with any exceptional\n    conditions.\n  * `node` {Object} The found NetBIOS node information or null if the search\n    failed.\n    * `nbname` {Object} The NetBIOS name of the node.\n    * `address` {String} The IPv4 address for the node.\n    * `group` {Boolean} A flag indicating if the found name is a group or\n      unique name.\n    * `ttl` {Number} The time-to-live of the node.\n    * `type` {String} The mode of the node such as 'broadcast' or 'hybrid'.\n\n### service.on('added', node)\n\nAn event emitted when either a local is registered or a remote name is\ndiscovered.\n\n* `node` {Object}\n  * `nbname` {Object} The NetBIOS name of the node.\n  * `address` {String} The IPv4 address for the node.\n  * `group` {Boolean} A flag indicating if the found name is a group or\n    unique name.\n  * `ttl` {Number} The time-to-live of the node.\n  * `type` {String} The mode of the node such as 'broadcast' or 'hybrid'.\n\n### service.on('removed', node)\n\nAn event emitted when either a local name is deregistered or remote name is\nremoved either due to release or cache expiration.\n\n* `node` {Object}\n  * `nbname` {Object} The NetBIOS name of the node.\n  * `address` {String} The IPv4 address for the node.\n  * `group` {Boolean} A flag indicating if the found name is a group or\n    unique name.\n  * `ttl` {Number} The time-to-live of the node.\n  * `type` {String} The mode of the node such as 'broadcast' or 'hybrid'.\n\n### service.on('error', error)\n\nAn event emitted when unhandled exceptional conditions occur.  Normally\nthis will only be things like failing to bind network sockets, etc.\n\n* `error` {Object}  The `Error` object\n\n[RFC1001]: http://tools.ietf.org/rfc/rfc1001.txt\n[RFC1002]: http://tools.ietf.org/rfc/rfc1002.txt\n[netbios-name]: https://github.com/wanderview/node-netbios-name\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/wanderview/node-netbios-name-service/issues"
  },
  "homepage": "https://github.com/wanderview/node-netbios-name-service",
  "_id": "netbios-name-service@0.3.2",
  "_from": "netbios-name-service@"
}
