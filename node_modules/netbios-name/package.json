{
  "name": "netbios-name",
  "description": "Utility code for working with NetBIOS names.",
  "keywords": [
    "netbios",
    "util",
    "utility",
    "name"
  ],
  "version": "0.2.0",
  "author": {
    "name": "Ben Kelly",
    "email": "ben@wanderview.com"
  },
  "license": "BSD",
  "dependencies": {},
  "devDependencies": {
    "nodeunit": "~0.7.4"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:wanderview/node-netbios-name.git"
  },
  "scripts": {
    "test": "nodeunit test"
  },
  "main": "name.js",
  "readme": "# node-netbios-name\n\nA utility module for working with NetBIOS names as defined in [RFC1001][],\n[RFC1002][], and [RFC883][].\n\n## Example\n\n    var NBName = require('netbios-name');\n\n    // The following two statements are equivalent\n    var nbname = new NBName({fqdn: 'foobar.example.com', suffix: 0x20});\n    var nbname = new NBName({name: 'foobar', scopeId: 'example.com',\n                             suffix: 0x20});\n\n    if (nbname.error) {\n      throw nbname.error;\n    }\n\n    nbname.name === 'foobar';                           // true\n    nbname.paddedName === 'foobar         ';            // true\n    nbname.scopeId === 'example.com';                   // true\n    nbname.fqdn === 'foobar.example.com';               // true\n    nbname.suffix === 0x20;                             // true\n    nbname.usage === 'File Server Service';             // true\n    nbname.toString() === 'foobar<20>.example.com';     // true\n\n    var buf = new Buffer(128);\n\n    var res = nbname.write(buf, 0, {});\n    if (res.error) {\n      throw res.error;\n    }\n\n    var nbname2 = NBName.fromBuffer(buf, 0);\n    if (nbname2.error) {\n      throw nbname2.error;\n    }\n\n    nbname2.bytesRead === res.bytesWritten;             // true\n    nbname2.name === nbname.name;                       // true\n    nbname2.scopeId === nbname.scopeId;                 // true\n    nbname2.fqdn === nbname.fqdn;                       // true\n    nbname2.suffix === nbname.suffix;                   // true\n    nbname2.usage === nbname.usage;                     // true\n\n## Class: NetbiosName\n\nThis class represents the name of a single NetBIOS node or service.  It\nconsists of the following properties:\n\n* `name` {String} The short NetBIOS name.  This is equivalent to the first\n  label in a fully qualified domain name.  The NetBIOS name is restricted\n  to a maximum length of 15 characters.\n* `scopeId` {String} The scope identifier or domain name that the node\n  belongs to.  For example, if the fully qualified domain name is\n  `host.example.com`, then the `scopeId` property will be `example.com`\n  and the `name` property above will be `host`.\n* `suffix` {Number} The trailing suffix byte that combines with the NetBIOS\n  name above to create a 16-byte fixed width field.  Microsoft popularized\n  the use of this byte for indicating the type or usage of the node.\n  Typically suffix byte values will be defined and displayed in hex; e.g.\n  `0x00` for workstations or `0x20` for file servers.\n\nIn addition to the basic properties, the class also derives the following\nvalues as a convenience:\n\n* `paddedName` {String} The same as the `name` field space padded out to\n  15 characters.\n* `fqdn` {String} The combination of the `name` field and the `scopeId` field.\n* `usage` {Sring} A human readable string describing the typical usage for\n  the given `suffix` byte.  If the `suffix` does not match a typical value,\n  then `usage` will be set to `'unknown'`.  These usage values are taken\n  from the Microsoft [NetBIOS Suffixes][] knowledge base article.\n\nFinally, instances of NetbiosName can also have additional properties based\non how the object was created:\n\n* `error` {Error Object} This property will be set if the constructor or\n  `fromBuffer()` method encounter an error while creating the NetbiosName\n  object.  This property should always be checked before using the instance\n  or any of its other properties.\n* `bytesRead` {Number} This property indicates how many bytes were read from\n  the buffer passed to `fromBuffer()` in order to create this instance.\n\nNote, all properties are set in the constructor or the `fromBuffer()` factory\nmethod.  If you write to one of the properties, don't expect any other values\nto get updated to reflect the change.\n\n### new NetbiosName(opts)\n\nConstruct a new NetbiosName instance for a given name and suffix.\n\n* `opts` {Object} A hash of named parameters.  Accepted options are:\n  * `fqdn` {String} The fully qualified domain name to use.\n  * `name` {String} The short NetBIOS name to use.  This is only referenced\n    if `fqdn` is not present.\n  * `scopeId` {String} The trailing domain name to be combined with the `name`\n    property.  This should not include a leading dot.  This is only\n    referenced if `fqdn` is not present.\n  * `suffix` {Number} The suffix byte value to use.  If this is not present\n    then the suffix defaults to 0x00 which typically represents a workstation\n    service.\n* Returns a new NetbiosName instance.  Note that if there are any problems\n  the `error` property of the NetbiosName object will be set.  Typically\n  errors only occur if a name is not provided or if its illegal due to length,\n  etc.\n\n### NetbiosName.fromBuffer(buf, offset)\n\nConstruct a new NetbiosName object from a binary buffer.\n\n* `buf` {Buffer Object} The buffer to read the name from.  Note, if this name\n  is being read from a message that uses name pointers, the first byte of the\n  buffer must correspond to the start of the message.  So don't just `slice()`\n  to the start of the name since the pointer offsets will be meaningless.\n* `offset` {Number} The offset from the start of the buffer indicating where\n  to begin reading.\n* Returns a new NetbiosName object instance.  Make sure to check the `error`\n  property on the returned object before using any other properties.  Also,\n  see the `bytesRead` property to determine how much of the buffer was\n  processed by this method.\n\n### nbname.write(buf, offset, nameMap)\n\nWrite the NetbiosName object instance out to the given buffer.\n\n* `buf` {Buffer Object} The buffer to write the name to.  Again, if name\n  pointers are going to be used, the start of the buffer must match the\n  start of the overall NetBIOS message.\n* `offset` {Number} Where to begin writing the name within the buffer.\n* `nameMap` {Object | null} If provided the location of the name within the\n  buffer will be stored in the `nameMap`.  If the same `nameMap` is used to\n  write the same name again or a portion of the name, then a name pointer\n  will used to compress the name within the buffer.  Passing `null` will\n  disable the use of name pointers.\n* Returns an Object containing two properties.\n  * `error` {Error Object} If an error occurred during writing this property\n    will be set.  The buffer may have been partially modified even if an\n    error occurs.\n  * `bytesWritten` {Number} The number of bytes written to the buffer.\n\n### nbname.toString()\n\nReturn a string representation of the NetBIOS name.  The format matches the\nstyle used by wireshark.  For example, a name of `foobar`, a scope ID of\n`example.com`, and suffix of `0x20` would be returned as the string\n`'foobar<20>.example.com'`.\n\nThe string returned contains all of the unique information in the name, so\nit can be reasonably used as the key for a hash.\n\n[RFC1001]: http://tools.ietf.org/rfc/rfc1001.txt\n[RFC1002]: http://tools.ietf.org/rfc/rfc1002.txt\n[RFC883]: http://tools.ietf.org/rfc/rfc883.txt\n[NetBIOS Suffixes]: http://support.microsoft.com/kb/163409\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/wanderview/node-netbios-name/issues"
  },
  "homepage": "https://github.com/wanderview/node-netbios-name",
  "_id": "netbios-name@0.2.0",
  "_from": "netbios-name@"
}
