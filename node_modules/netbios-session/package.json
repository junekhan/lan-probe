{
  "name": "netbios-session",
  "description": "NetBIOS session implementation written in Javascript.",
  "keywords": [
    "netbios",
    "session"
  ],
  "version": "0.1.6",
  "author": {
    "name": "Ben Kelly",
    "email": "ben@wanderview.com"
  },
  "license": "BSD",
  "dependencies": {
    "netbios-name": "~0.2.0",
    "readable-stream": "~1.0.0"
  },
  "devDependencies": {
    "nodeunit": "~0.7.4",
    "pcap-socket": "~0.5.0"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:wanderview/node-netbios-session.git"
  },
  "scripts": {
    "test": "nodeunit test"
  },
  "main": "session.js",
  "readme": "# netbios-session\n\nA 100% javascript implemention of the NetBIOS session protocol defined in\n[RFC1001][] and [RFC1002][].\n\n[![Build Status](https://travis-ci.org/wanderview/node-netbios-session.png)](https://travis-ci.org/wanderview/node-netbios-session)\n\n## Example\n\n``` javascript\nvar Session = require('netbios-session')\nvar net = require('net');\n\nvar NAME = null;\n\nvar server = net.createServer(function(socket) {\n  console.log('---> new connection from [' + socket.remoteAddress + ']');\n  var session = new Session();\n  session.attach(socket, function(error, request) {\n    if (error) {\n      console.log('---> attach error [' + error + ']');\n      return;\n    }\n\n    console.log('---> new call to [' + request.callTo + '] from [' +\n                request.callFrom + ']');\n\n    if (NAME && request.callTo.name !== NAME) {\n      console.log('---> rejecting');\n      request.reject('Not listening on called name');\n      return;\n    }\n\n    session.on('message', function(msg) {\n      console.log('---> received a message with [' + msg.length + '] bytes');\n    });\n\n    console.log('---> accepting');\n    request.accept();\n  });\n});\n\nserver.listen(139, function() {\n  console.log('server started');\n});\n```\n\n## Limitations\n\nThis module provides a useful set of functionality from the RFCs, but it is\nstill a work in progress.\n\nPlease be aware of the following limitations:\n\n* Currently the code does not support session retargeting.  This can be used\n  to instruct a client to close its current connection and try again at a\n  different address.  Currently redirection responses are ignored.\n* The API should be considered unstable as it may change in future versions.\n\nFeedback, testing help, and pull requests welcome.\n\n## Class: NetbiosSession\n\nThe NetbiosSession class represents a message based session with a remote\nhost.  There is an initial session negotiation process that requires the\ncaller to request a new session for a particular name.  The other peer\ncan then accept or reject the request.  Once a request has been accepted the\nsession is considered to be connected.  At this point messages can be sent\nand received.\n\nNetbiosSession inherits from [EventEmitter][] class.\n\n### new NetbiosSession(options)\n\nCreate a new NetbiosSession instance with the given `options`.\n\n* `options` {Object | null} Optional configuration options for the session.\n  Possible values are:\n  * `autoAccept` {Boolean} If set to `true`, then the session will default\n    to accepting all requests if an `attach()` `callback` is not provided.\n    Default value is `false`\n  * `direct` {Boolean} Use direct connection mode if this option is set.\n    This means that the session establishment handshake should not be\n    performed.  Instead, consider the session connected as soon as we have\n    a valid TCP socket.  This is useful for protocols like SMB that still\n    want a NetBIOS message header, but do not use the request/response\n    commands.\n  * `paused` {Boolean} If set the session will start in the paused condition.\n    This means that the session can connect or attach as needed, but no\n    `'message'` events will occur until `resume()` is called.\n\n### session.attach(socket, callback)\n\nAttach the session to a `net.Socket` instance and wait to receive an incoming\nNetBIOS session request.  This is typically used to handle in the `net.Server`\n`'connection'` event.\n\nIf provided, the `callback` will be called when the request is initiated.  It\nis also important for the `callback` implementation to either accept or reject\nthe request.  This is done by calling `request.accept()` or `request.reject()`.\nIf neither of these methods is called, then the session request negotiation\nprocess will stall.  If a `callback` is not provided, then the default\npolicy will be used to either reject or accept.\n\n* `socket` {Socket Object} The socket to attach to.  This socket should\n  already be bound and connected.\n* `callback` {Function | null} An optional callback that is used to signal\n  that a request has occured and to approve or deny the request.  NOTE: If the\n  `direct` option was set in the session constructor, then this callback will\n  not be called.\n  * `error` {Error Object} Provided if an error occurs during the attachment.\n  * `request` {Object} An object describing the session request and providing\n    method to allow the `callback` to `accept()` or `reject()` the request.\n    NOTE:  One of these methods must be called.\n    * `callTo` {NetbiosName} The [NetbiosName][] object representing the\n      service the session is trying to connect to.\n    * `callFrom` {NetbiosName} The [NetbiosName][] object representing the\n      service that is initiating the session.\n    * `accept` {Function} Call this method to accept the request and allow\n      the session to proceed.  Can be called asynchronously\n    * `reject` {Function} Call this method to reject the request and to\n      close the underlying socket.  A `reason` string can optionally be\n      provided.  The `reject()` method can be called asynchronously.\n      * `reason` {String | null} A string from an enumerated list of values\n        that can optionally be provided.  If not specified then `Unspecified\n        error` is used.  See below for other valid reasons.\n\nValid reason strings are:\n\n* `'Not listening on called name'`\n* `'Not listening for calling name'`\n* `'Called name not present'`\n* `'Called name present, but insufficient resources'`\n* `'Unspecified error'`\n\n### session.connect(port, host, callTo, callFrom, callback)\n\nInitiate a new NetBIOS session with a remote host.  This method will open a\nnew socket and connect to the given `host` and `port`.  A session will then\nbe requested for the given `callTo` name coming from the given `callFrom`\nname.  These must be [NetbiosName][] object instances.  The remote host\ncan then accept or reject the session based on the names provided.  The\n`callback` will be called once the connection successfully completes or\nhas been rejected.\n\n* `port` {Number} The remote port number to connect to.  Normally this should\n  be port 139 for most NetBIOS session servers.\n* `host` {String} The remote host name to connect to.\n* `callTo` {NetbiosName Object} The [NetbiosName][] representing the service\n  you are trying to connect to.\n* `callFrom` {NetbiosName Object} The [NetbiosName][] representing the local\n  service initiating the session.\n* `callback` {Function | null}  The function that will be called once both\n  the underlying socket and the session have fully connected.\n  * `error` {Error Object | null} If an error occurred it will be passed.  If\n    the connection was rejected, then `error` will be set with the result code\n    provided by the remote host.\n\n### session.write(msg, callback)\n\nWrite the given `msg` out to the remote session peer.  If the message can\nbe fully flushed to the kernel, then `write()` will return `true`.  If `false`\nis returned, you should wait until the next `'drain'` event before writing\nmore data to the session.\n\n* `msg` {Buffer Object} The message `Buffer` to send to the remote session\n  peer.  Note, the message can be at most `NetbiosSession.MAX_MESSAGE_LENGTH`\n  bytes long.\n* `callback` {Function | null}  Optional function that will be called once\n  the `msg` object has been written out or when an error occurs.\n  * `error` {Error Object | null} The error that occurred, if any.\n\n### session.pause()\n\nStop accepting messages from the remote session peer.  This can be used\nto implement back pressure if the messages are coming too fast.  Note,\nthe session can still negotiate the connection even if paused, so there\nmay still be network traffic if the session is not yet connected.\n\n### session.resume()\n\nResume accepting message from the remote session peer.\n\n### Constant: `session.MAX_MESSAGE_LENGTH`\n\nMaximum number of bytes that can be passed to a single `write()` method\ncall to be sent as a message.  Also, messages received will not exceed\nthis limit as well.\n\n### Event: 'connect'\n\nWhen the NetbiosSession has negotiated and established a new session, the\n`'connect'` event will be emitted.\n\n### Event: 'message'\n\nWhenever a message is received from the remote session peer, a `'message'`\nevent will be emitted.\n\n* `msg` {Buffer Object}  A `Buffer` containing the message received.\n\n### Event: 'end'\n\nThe `'end'` event is emitted when the session can no longer send or receive\nmessages.\n\n### Event: 'error'\n\nThe `'error'` event is emitted when an error is encountered.\n\n* `error` {Error Object} The error that occured.\n\n[RFC1001]: http://tools.ietf.org/rfc/rfc1001.txt\n[RFC1002]: http://tools.ietf.org/rfc/rfc1002.txt\n[NetbiosName]: http://www.github.com/wanderview/node-netbios-name\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/wanderview/node-netbios-session/issues"
  },
  "homepage": "https://github.com/wanderview/node-netbios-session",
  "_id": "netbios-session@0.1.6",
  "_from": "netbios-session@"
}
